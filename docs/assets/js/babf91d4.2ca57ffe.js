"use strict";(self.webpackChunkpatterns_site=self.webpackChunkpatterns_site||[]).push([[7398],{2137:t=>{t.exports=JSON.parse('{"label":"behavioral","permalink":"/patterns/docs/tags/behavioral","allTagsPath":"/patterns/docs/tags","count":7,"items":[{"id":"patterns/Chain","title":"Chain","description":"Chain of responsibility pattern allows an object to send a command without knowing what object will receive and handle it. Chain the receiving objects and pass the request along the chain until an object handles it","permalink":"/patterns/docs/patterns/Chain"},{"id":"patterns/Decorator","title":"Decorator","description":"Decorator allows behavior to be added to an individual object, either statically or dynamically, without affecting the behavior of other objects from the same class.","permalink":"/patterns/docs/patterns/Decorator"},{"id":"patterns/IOC","title":"IOC","description":"Inversion of Control is a principle in software engineering by which the control of objects or portions of a program is transferred to a container or framework. It\'s a design principle in which custom-written portions of a computer program receive the flow of control from a generic framework.","permalink":"/patterns/docs/patterns/IOC"},{"id":"patterns/Iterator","title":"Iterator","description":"Iterator design pattern allows to traverse a container and access the container\'s elements.","permalink":"/patterns/docs/patterns/Iterator"},{"id":"patterns/NullObject","title":"NullObject","description":"Instead of returning null , use an object which implements the expected interface, but whose method body is empty.","permalink":"/patterns/docs/patterns/NullObject"},{"id":"patterns/Strategy","title":"Strategy","description":"Strategy pattern allows a client to choose from a family of algorithms at runtime. It is used when the client expects to have multiple algorithms and wants to choose one of them at runtime.","permalink":"/patterns/docs/patterns/Strategy"},{"id":"patterns/Visitor","title":"Visitor","description":"Visitor pattern is a way of separating an algorithm from an object structure on which it operates. A practical result of this separation is the ability to add new operations to existing object structures without modifying the structures.","permalink":"/patterns/docs/patterns/Visitor"}],"unlisted":false}')}}]);
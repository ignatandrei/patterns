"use strict";(self.webpackChunkpatterns_site=self.webpackChunkpatterns_site||[]).push([[5658],{7870:(t,e,r)=>{r.r(e),r.d(e,{assets:()=>l,contentTitle:()=>s,default:()=>p,frontMatter:()=>a,metadata:()=>o,toc:()=>c});var n=r(4848),i=r(8453);const a={id:"Visitor",title:"Visitor",tags:["Visitor","https://github.com/ignatandrei/patterns","behavioral","design pattern","Visitor"]},s="Pattern:  Visitor",o={id:"patterns/Visitor",title:"Visitor",description:"Visitor pattern is a way of separating an algorithm from an object structure on which it operates. A practical result of this separation is the ability to add new operations to existing object structures without modifying the structures.",source:"@site/docs/patterns/Visitor.md",sourceDirName:"patterns",slug:"/patterns/Visitor",permalink:"/patterns/docs/patterns/Visitor",draft:!1,unlisted:!1,tags:[{label:"Visitor",permalink:"/patterns/docs/tags/visitor"},{label:"https://github.com/ignatandrei/patterns",permalink:"/patterns/docs/tags/https-github-com-ignatandrei-patterns"},{label:"behavioral",permalink:"/patterns/docs/tags/behavioral"},{label:"design pattern",permalink:"/patterns/docs/tags/design-pattern"}],version:"current",frontMatter:{id:"Visitor",title:"Visitor",tags:["Visitor","https://github.com/ignatandrei/patterns","behavioral","design pattern","Visitor"]},sidebar:"tutorialSidebar",previous:{title:"Strategy",permalink:"/patterns/docs/patterns/Strategy"},next:{title:"DocusaurusTutorial",permalink:"/patterns/docs/category/docusaurustutorial"}},l={},c=[{value:"Example in .NET :",id:"example-in-net-",level:2},{value:"Visitor",id:"visitor",level:3},{value:"Learn More",id:"learn-more",level:2},{value:"Homework",id:"homework",level:2}];function d(t){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,i.R)(),...t.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h1,{id:"pattern--visitor",children:"Pattern:  Visitor"}),"\n",(0,n.jsx)(e.p,{children:"Visitor pattern is a way of separating an algorithm from an object structure on which it operates. A practical result of this separation is the ability to add new operations to existing object structures without modifying the structures."}),"\n",(0,n.jsx)(e.h2,{id:"example-in-net-",children:"Example in .NET :"}),"\n",(0,n.jsx)(e.h3,{id:"visitor",children:"Visitor"}),"\n",(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:"language-csharp",metastring:'showLineNumbers title="Visitor example for Pattern Visitor"',children:'using Microsoft.CodeAnalysis;\r\nusing Microsoft.CodeAnalysis.CSharp;\r\nusing Microsoft.CodeAnalysis.CSharp.Syntax;\r\n\r\nnamespace Visitor;\r\ninternal class VisitorDemo\r\n{\r\n    public static void VisitMethods()\r\n    {\r\n        var Code = @"""\r\nusing System;\r\nnamespace Test1\r\n{\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n              var dt=DateTime.Now;\r\n\t\t\t  Console.WriteLine(dt);\r\n        }\r\n     }\r\n}\r\n\r\n""";\r\n        var tree = CSharpSyntaxTree.ParseText(Code);\r\n\r\n        var node = tree.GetRoot();\r\n\r\n        MethodVisiting LG = new MethodVisiting();\r\n        //start visiting\r\n        var sn = LG.Visit(node);\r\n\r\n    }\r\n}\r\npublic class MethodVisiting : CSharpSyntaxRewriter\r\n{\r\n    public override SyntaxNode? VisitMethodDeclaration(MethodDeclarationSyntax node)\r\n    {\r\n        if (node.Body == null || node.Body.Statements.Count == 0)\r\n            return base.VisitMethodDeclaration(node);\r\n\r\n        var parent = node.Parent as ClassDeclarationSyntax;\r\n        \r\n        if (parent == null)\r\n            return base.VisitMethodDeclaration(node);\r\n\r\n        var nameMethod = node.Identifier.Text;\r\n        var nameClass = parent.Identifier.Text;\r\n        Console.WriteLine($"visiting {nameMethod} from {nameClass}");\r\n\r\n        return base.VisitMethodDeclaration(node);\r\n\r\n    }\r\n}\n'})}),"\n",(0,n.jsx)(e.h2,{id:"learn-more",children:"Learn More"}),"\n",(0,n.jsx)(e.p,{children:(0,n.jsx)(e.a,{href:"https://en.wikipedia.org/wiki/Visitor_pattern",children:"Wikipedia"})}),"\n",(0,n.jsx)(e.h2,{id:"homework",children:"Homework"}),"\n",(0,n.jsx)(e.p,{children:"Implement a visitor that will allow you to calculate the total price of a shopping cart. The shopping cart should contain items with a price and a quantity.Visit every item and make the sum"})]})}function p(t={}){const{wrapper:e}={...(0,i.R)(),...t.components};return e?(0,n.jsx)(e,{...t,children:(0,n.jsx)(d,{...t})}):d(t)}},8453:(t,e,r)=>{r.d(e,{R:()=>s,x:()=>o});var n=r(6540);const i={},a=n.createContext(i);function s(t){const e=n.useContext(a);return n.useMemo((function(){return"function"==typeof t?t(e):{...e,...t}}),[e,t])}function o(t){let e;return e=t.disableParentContext?"function"==typeof t.components?t.components(i):t.components||i:s(t.components),n.createElement(a.Provider,{value:e},t.children)}}}]);
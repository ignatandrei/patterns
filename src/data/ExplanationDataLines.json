[
  {
    "Id": 17,
    "Line1": "You want to create commands for any specific database type in order to obtain data from a database",
    "Line10": "By using an Abstract Factory, your application can remain agnostic of the specific type of database it is interacting with",
    "Line2": "This means you can switch between different databases (e.g., SQL Server, MySQL, PostgreSQL) without changing the core logic of your application",
    "Line3": "The factory will provide the appropriate concrete implementation of the DBConnection for the database in use.",
    "Line4": "",
    "Line5": "",
    "Line6": "",
    "Line7": "",
    "Line8": "",
    "Line9": ""
  },
  {
    "Id": 4,
    "Line1": "You want to  transfer data from a database Command to a DataTable",
    "Line2":"The SQLiteDataAdapter serves as an adapter between the SQLiteCommand object (which represents a SQL command or stored procedure to execute against a SQLite database) and the DataTable object (which represents in-memory data in a tabular format)"
  },
  {
    "Id":1,
    "Line1":"You want to let the developer construct a SqlConnectionString",
    "Line2":"The SqlConnectionStringBuilder class provides a way to construct connection strings for SQL Server databases",
    "Line3":"Instead of requiring the developer to construct a connection string in one go, potentially leading to mistakes or omissions, SqlConnectionStringBuilder allows for the step-by-step construction of a connection string",
    "Line4":"This can help to ensure that all necessary parameters are included and that the connection string is correctly formatted",
    "Line5":"Once all necessary parameters have been set, the ConnectionString property of the SqlConnectionStringBuilder object can be used to retrieve the constructed connection string"
  },
  {
    "Id":9,
    "Line1":"You want to pass the exception to the possible handlers / catch blocks in the all functions in the call stack",
    "Line2":"Exception bubbling in .NET exemplifies the Chain of Responsibility pattern by allowing exceptions to be passed along a chain of potential handlers (catch blocks) until one is found that can handle the exception",
    "Line3":"This can be useful when you want to ensure that exceptions are handled at the appropriate level of abstraction, rather than being caught and handled at a lower level where they may not be fully understood or properly addressed",
    "Line4":"By allowing exceptions to bubble up the call stack, you can ensure that they are handled in a consistent and appropriate manner, regardless of where they occur in the code",
    "Line5":"This mechanism decouples the thrower of the exception from the handlers, providing a flexible and dynamic way of managing errors that occur during runtime"
  },
  {
    "Id":8,
    "Line1":"Stream is a perfect example of the Decorator pattern",
    "Line2":"Imagine you want to write a text to a file, but you want to add some additional functionality(or not, at will) to the stream, such as  compression or encryption.",
    "Line3":"By using the Decorator pattern, you can easily compose streams with different behaviors to create custom stream objects that meet specific requirements", 
    "Line4":"Each stream class focuses on a single responsibility. FileStream handles file I/O, CryptoStream handles encryption and decryption, and GZipStream handles compression and decompression. This makes the classes easier to understand, test, and maintain."
  }

]